<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>15balloon.github.io/</title>
   
   <link>https://15balloon.github.io</link>
   <description>Develop and Write</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Flutter 터치하지 않았는데 onTap 불리는 문제 해결</title>
	  <link>/2024-03-15-Flutter-onTap-Issue</link>
	  <author></author>
	  <pubDate>2024-03-15T21:01:37+09:00</pubDate>
	  <guid>/2024-03-15-Flutter-onTap-Issue</guid>
	  <description><![CDATA[
	     <p>Card 위젯을 사용해 데이터 목록을 표시하는 레이아웃을 만들었다. <br />
그리고 하나의 Card 위젯을 선택할 수 있도록 GestureDetector 위젯을 사용했다. <br />
(이후에 InkWell 위젯도 알게 되었다…!) <br />
onTap callback 함수를 작성하여 Card 위젯이 선택되면 border를 표시하도록 했다.</p>

<h4 id="이상-현상">이상 현상</h4>
<p>레이아웃이 포함된 화면으로 전환될 때 빨간 화면이 떴다. <br />
오류를 보니 (대충) 찬물도 위아래가 있는데 UI가 그려지기도 전에 UI를 변경하자고 우기면 어떡하냐는 내용이었다. <br />
로그를 찍어 봤는데 단지 화면이 전환되었을 뿐인데 onTap이 불렸다. <br />
터치한게 아니고 화면이 표시되었을 뿐인데 onTap이 불린 것이다.</p>

<h4 id="문제-해결">문제 해결</h4>
<p>바로 오류 상황을 구글에 검색해보니 역시나 누군가가 질문한 글이 있었다. <br />
답변은 다음과 같다. <br />
onTap은 GestureTapCallback 함수의 한 종류이기 때문에</p>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Wrong code</span>
<span class="nl">onTap:</span> <span class="n">somethingFunction</span><span class="o">(),</span>
</code></pre></div></div>
<p>이렇게 사용하면 사용자의 Tap 입력없이 바로 함수가 실행된다. <br />
그러니 다음과 같이 사용해야 한다.</p>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Correct code</span>
<span class="nl">onTap:</span> <span class="o">()</span> <span class="o">{</span><span class="n">somethingFunction</span><span class="o">()},</span>
</code></pre></div></div>
<p>답변을 보고 코드를 보니 정말 저렇게 잘못 작성했다. <br />
답변대로 작성하여 문제를 해결할 수 있었다.</p>

<p>조금만 생각해보면 onTap은 함수 타입이고 somethingFunction은 void 타입이라 오동작했다는 것을 깨달을 수 있었을 텐데 왜 그 당시에는 그런 생각이 안 떠올랐는지 모르겠다.</p>

<h4 id="conclusion">Conclusion</h4>
<p>프로젝트 마감 기한이 촉박해서 어쩔 수 없이 아무런 지식이 없는 상태로 당장 Flutter 개발을 시작하게 되었다. <br />
지금 글을 작성한 시점 기준 Flutter를 시작한지 2주가 되었다. <br />
그래서 Dart 언어와 Flutter 기초 지식이 너무나도 부족했다. <br />
그나마 레이아웃 구성이 Jetpack Compose와 유사하다는 것이 위안이다.</p>

<p>Java, Kotlin과 Dart가 어떤 부분이 다른지 아예 모르니 코드를 작성하면서 이게 왜 안 되지 하는 순간이 있었다. <br />
Dart에서 람다식은 무조건 한 줄로만 작성해야 한다는 것도 이번에 처음 알게 되었다. <br />
그리고 Dart 언어 특성을 살려서 코드를 작성하는 것 같지 않아서(느낌적인 느낌) 아쉽다. <br />
유지보수하면서 조금씩 고쳐나가야 겠다.</p>

<p>Dart랑 Flutter 공식 문서가 정말 잘 작성되어 있다. <br />
어떤 요소를 사용하고 싶은지만 알아내서 공식 문서만 보고 코드를 짜도 괜찮았다. <br />
아무래도 구글이 출시한 프레임워크라서 그런 것 같다.</p>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://stackoverflow.com/questions/75600597/why-ontap-function-runs-without-tapping-when-it-have-arguments">Why onTap function runs without tapping when it have arguments?</a></li>
  <li><a href="https://dart-ko.dev/language/functions">Dart - 함수</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Flutter WebView 흰 화면 문제 해결</title>
	  <link>/2024-03-13-Flutter-WebView-Issue</link>
	  <author></author>
	  <pubDate>2024-03-13T23:14:13+09:00</pubDate>
	  <guid>/2024-03-13-Flutter-WebView-Issue</guid>
	  <description><![CDATA[
	     <p>회사에서 새로운 프로젝트를 진행하게 되었다. <br />
일단은 안드로이드 앱을 먼저 출시하겠지만 추후 iOS 앱도 출시해야 하기 때문에 Flutter로 개발하기로 했다. <br />
이 프로젝트는 PG사 결제 연동도 구현해야 하는데, 결제 기능이 WebView를 통해 이루어지고 있어서 <strong>webview_flutter</strong> 라이브러리를 사용해서 개발을 하였다.</p>

<h4 id="이상-현상">이상 현상</h4>
<p>결제 모듈을 앱에 붙여서 테스트를 진행하였는데, 다른 앱으로 전환했다가 다시 앱에 진입하면 <strong>WebView가 흰 화면으로 보여지는 문제</strong>가 발생했다. <br />
로그를 찍어 살펴보니 다시 앱에 진입할 때 WebView가 두 번씩 reload 되고 있는데 이게 문제인건지 알 수가 없었다. <br />
그래서 구글 검색을 해보니 Flutter Github의 Issue 탭에 올라온 글을 발견할 수 있었다.</p>

<h4 id="문제-해결">문제 해결</h4>
<p>webview_flutter 라이브러리 사용 시 Android 14 버전을 가진 삼성 기기에서 흰 화면이 표시되는 문제가 있다는 것을 어떤 사람이 리포트한 것이다. <br />
갤럭시 S23에 Android 14가 정식 배포된게 11월인데 글이 11월 말에 올라왔으니 거의 바로 리포트된 셈이다. <br />
글을 쭉 읽으면 삼성에도 이 문제를 알렸지만 아직까지도 별다른 대응은 없는 것을 확인할 수 있다. <br />
<em>mxnortal</em>이라는 유저가 임시 해결 방안을 올려놓았는데, 이를 적용하여 문제를 해결할 수 있었다. <br />
코드를 살펴보면 다음과 같다.</p>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@override</span>    
<span class="kt">void</span> <span class="nf">didChangeAppLifecycleState</span><span class="p">(</span><span class="n">AppLifecycleState</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">AppLifecycleState</span><span class="o">.</span><span class="na">resumed</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">_shouldReloadWebView</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">_shouldReloadWebView</span><span class="o">()</span> <span class="n">async</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Platform</span><span class="o">.</span><span class="na">isAndroid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kd">var</span> <span class="n">androidInfo</span> <span class="o">=</span> <span class="n">await</span> <span class="n">DeviceInfoPlugin</span><span class="o">().</span><span class="na">androidInfo</span><span class="o">;</span>
            <span class="kd">var</span> <span class="n">sdkInt</span> <span class="o">=</span> <span class="n">androidInfo</span><span class="o">.</span><span class="na">version</span><span class="o">.</span><span class="na">sdkInt</span><span class="o">;</span>
            <span class="kd">var</span> <span class="n">manufacturer</span> <span class="o">=</span> <span class="n">androidInfo</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">sdkInt</span> <span class="o">==</span> <span class="mi">34</span> <span class="o">&amp;&amp;</span> <span class="n">manufacturer</span> <span class="o">==</span> <span class="s">'samsung'</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">setState</span><span class="o">(()</span> <span class="o">{</span>
                    <span class="n">_isInProgress</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">});</span>

                <span class="n">Future</span><span class="o">.</span><span class="na">delayed</span><span class="o">(</span><span class="kd">const</span> <span class="n">Duration</span><span class="o">(</span><span class="nl">milliseconds:</span> <span class="mi">300</span><span class="o">),</span> <span class="o">()</span> <span class="o">{</span>
                    <span class="n">setState</span><span class="o">(()</span> <span class="o">{</span>
                        <span class="n">_isInProgress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">});</span>
                <span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">_</span><span class="o">)</span> <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">_isInProgress</span>
      <span class="o">?</span> <span class="kd">const</span> <span class="n">SizedBox</span><span class="o">.</span><span class="na">shrink</span><span class="o">()</span>
      <span class="o">:</span> <span class="n">WebViewWidget</span><span class="o">();</span>
</code></pre></div></div>
<p>onResume 상태가 된 경우, 사용하는 기기가 삼성 기기이면서 Android 14 버전이면 빈 widget을 그렸다가 WebView를 그린다. <br />
이렇게 코드를 수정하면 다른 앱으로 전환 후에 다시 돌아와도 WebView가 잘 보이는 것을 확인할 수 있다.</p>

<h4 id="conclusion">Conclusion</h4>
<p>삼성 기기만의 문제일 것이라고는 생각도 못해서 빠르게 해결하지는 못했다. <br />
Flutter도 처음이었고, 결제 모듈 연동도 처음이어서 코드에 문제가 있지 않을까 라는 생각이 먼저 들었기 때문이다. <br />
다행히 Issue에 리포트된 사항이었고, 임시 해결 방안까지 있어서 해결할 수 있었다. <br />
물론 이후에 POST 방식으로 데이터를 전송함과 동시에 페이지를 여는 기능이 필요해져서 <strong>flutter_inappwebview</strong> 라이브러리를 사용하게 되어 이 해결 방안을 사용하게 되진 않았지만 말이다.</p>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://github.com/flutter/flutter/issues/139039">Samsung phones running Android 14 stops drawing platform views on resume</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>View Binding Migration 문제 해결</title>
	  <link>/2024-01-30-ViewBinding-Migration-Issue</link>
	  <author></author>
	  <pubDate>2024-01-30T23:19:59+09:00</pubDate>
	  <guid>/2024-01-30-ViewBinding-Migration-Issue</guid>
	  <description><![CDATA[
	     <p>회사에 대략 6년 정도 된 앱이 하나 있는데, 그 앱을 담당했던 분이 퇴사하면서 내가 그 앱의 담당자가 되었다. <br />
전 담당자분은 앱 개발자는 아니었지만, 개발하셨던 것 같다. <br />
(타 부서라 잘 몰랐고, 그래서 이런 앱이 있는지도 몰랐다) <br />
아무튼 오래된 앱이고 개발자의 전문 분야가 앱이 아니다 보니 전체적으로 기술이 낡아 있었다. <br />
앱 전체가 Java로 되어 있었고, View Binding이나 Retrofit2도 사용하지 않았다. <br />
이 앱 담당자가 되었을 때부터 기술을 조금이라도 최신화하고 싶었지만, 진행하는 주 프로젝트가 있었고 이건 서브였기 때문에 언젠가 틈이 나기만을 기다렸다. <br />
그러다 이번에 시간이 조금 나서 일부 코드를 Kotlin으로의 Migration과 View Binding을 사용하도록 수정하는 작업을 진행하였다.</p>

<h4 id="이상-현상">이상 현상</h4>
<p>먼저 Activity와 같은 주요 클래스들을 먼저 수정하였는데, 이 과정에서 문제가 발생했다. <br />
setContentView() 수행 시 R.layout.activity_xxx 대신 View Binding을 사용하도록 변경하였는데 View가 다르게 보였다. <br />
<img src="/assets/images/2024-01-30-ViewBinding-Migration-Issue_1.jpg" width="100%" height="100%" title="normal view" alt="Image: Original View" />
이렇게 보여야 하는 View인데,
<img src="/assets/images/2024-01-30-ViewBinding-Migration-Issue_2.jpg" width="40%" height="40%" title="problem view" alt="Image: Problem View" />
이렇게 보였다.</p>

<h4 id="코드-구조">코드 구조</h4>
<p>해당 View의 간략한 구조는 다음과 같다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;LinearLayout</span>
    <span class="na">android:layout_width=</span><span class="s">"100dp"</span>
    <span class="na">android:layout_height=</span><span class="s">"match_parent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;TextView</span>
        <span class="na">android:layout_width=</span><span class="s">"wrap_content"</span>
        <span class="na">android:layout_height=</span><span class="s">"40dp"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/LinearLayout&gt;</span>
</code></pre></div></div>

<p>최상단에 LinearLayout이 있고 width가 100dp로 고정되어 있다. <br />
그리고 그 하위에 TextView가 있고 width는 wrap_content로 설정되어 있다.</p>

<p>다른 View들은 괜찮았는데 딱 그 View만 문제였다. <br />
다른 View와 차이가 뭔지 살펴보니 이 View는 Manifest에 theme가 Dialog로 설정되어 있었다.</p>

<h4 id="문제-해결">문제 해결</h4>
<p>Dialog Theme는 해당 View에 포함된 실제 View의 크기에 따라 공간을 차지하게 되어 있다. <br />
그렇다 하더라도 LinearLayout의 width가 고정값이기 때문에 해당 크기에 맞춰 공간을 차지해야 하는데 이 값이 무시되었다. <br />
처음엔 View Binding에 문제가 있다고 판단하였는데, 그것이 아니고 overloading된 setContentView() 메소드에 차이가 있었다. <br />
setContentView(@LayoutRes int)를 수행할 때는 기존에 설정된 레이아웃 매개변수를 그대로 사용하지만, setContentView(View)를 수행할 때는 레이아웃 매개변수가 무시되고 width와 height가 match_parent로 설정된다. <br />
(width와 height가 match_parent로 설정된 건 Layout Inspector Tool로 확인할 수 있다) <br />
<img src="/assets/images/2024-01-30-ViewBinding-Migration-Issue_3.jpg" width="100%" height="100%" title="setContentView" alt="Image: setContentView" />
이 설명은 Activity.class 파일에서 확인할 수 있다.</p>

<p>따라서 아래와 같이 inflater를 사용하여 view 객체를 생성한 경우 setContentView(View) 메소드를 사용하므로 LinearLayout의 width 값이 match_parent로 바뀌어서 View가 다르게 보이게 된다.</p>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">inflater</span> <span class="p">=</span> <span class="nf">getSystemService</span><span class="p">(</span><span class="nc">Context</span><span class="p">.</span><span class="nc">LAYOUT_INFLATER_SERVICE</span><span class="p">)</span> <span class="k">as</span> <span class="nc">LayoutInflater</span>
<span class="kd">val</span> <span class="py">view</span> <span class="p">=</span> <span class="n">inflater</span><span class="p">.</span><span class="nf">inflate</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_xxx</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="nc">View</span>
<span class="nf">setContentView</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="해결-방법">해결 방법</h4>
<p>이를 해결하기 위해서는 Activity.class 파일에 쓰여 있는 설명대로 setContentView(View, ViewGroup.LayoutParams) 메소드를 사용하면 된다.</p>

<h4 id="conclusion">Conclusion</h4>
<p>Migration 과정에서 발생한 문제를 해결하며 findViewById와 View Binding의 동작 원리에 대해서 다시 한번 살펴보게 되었고, setContentView() 메소드 종류가 다양하다는 것과 동작에 차이가 있다는 것을 알게 되었다.</p>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://stackoverflow.com/questions/61695769/why-using-view-binding-is-changing-the-layout">Why using View Binding is changing the layout?</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Clean Architecture 알아보기</title>
	  <link>/2024-01-05-Clean-Architecture</link>
	  <author></author>
	  <pubDate>2024-01-05T23:38:02+09:00</pubDate>
	  <guid>/2024-01-05-Clean-Architecture</guid>
	  <description><![CDATA[
	     <p>OlymPos 프로젝트를 시작하면서 공부해야 겠다고 마음먹은 것들이 많았는데, 그중 하나가 클린 아키텍처다. <br />
다들 클린 아키텍처 클린 아키텍처 하니 이게 도대체 뭔진 몰라도 공부해봐야 겠다는 생각이 들었다. <br />
기본적인 Layered Architecture(계층 아키텍처)와 Clean Architecture(클린 아키텍처)의 개념과 이 둘의 차이점을 알아볼 것이다. <br />
또한 아키텍처를 사용하는 이유와 아키텍처 선택 기준에 대하여 생각해보고 이를 정리하고자 한다.</p>

<h4 id="용어-정리">용어 정리</h4>
<p>Persistence(영속성): 데이터를 생성한 프로그램이 종료되어도 데이터가 지속되는 특성. DB에 저장된 데이터는 영속성을 가진 것이고, 메모리 상에 존재하는(변수에 저장된) 데이터는 영속성을 가지지 않은 것이다. <br />
Business Rule(비즈니스 규칙): 어떤 일이 발생했을 때 수행하는 구체적인 일(ex.주문이 들어오면 상품 수량을 하나 줄임) <br />
Business Role(비즈니스 역할): 사용자가 버튼을 클릭하면 발생하는 어떤 일(ex.주문 접수) <br />
Business Logic(비즈니스 로직): (비즈니스 규칙 + 비즈니스 역할) 특정 요청(ex. 상품 구매하기)에 따른 주요 로직(ex. 상품, 배송지 정보 가져오기, 결제하기 등)의 집합. <br />
Database Driven Development(데이터베이스 주도 설계): 데이터베이스를 먼저 설계하고, 이를 토대로 패키지를 구성하고, 데이터를 조작하는데 필요한 메소드를 만드는 방식으로 개발을 수행하는 방식 <br />
Domain Driven Development(도메인 주도 설계): 비즈니스 역할과 규칙을 먼저 정의하고 이를 중심으로 설계하는 방식</p>

<h4 id="layered-architecture">Layered Architecture</h4>
<p>단순한 구조로 이루어져 있으며 기본적인 아키텍처이다. <br />
UI(Presentation) Layer, Business Logic(Domain) Layer, Data Access(Persistence) Layer로 분리되어 있다.</p>
<ul>
  <li>UI Layer - 사용자와의 상호작용을 수행하고 사용자에게 데이터를 보여준다.</li>
  <li>Business Logic Layer - 어플리케이션의 모든 비즈니스 로직을 수행한다.</li>
  <li>Data Access Layer - DB나 파일같은 데이터 저장소에 접근하여 필요한 데이터를 가져오는 역할이다.</li>
</ul>

<p>각 계층의 관계는 다음과 같다. <br />
의존성이 <strong>하위 계층</strong>(여기에선 Data Access)으로 향한다. <br />
간단히 말하면 UI 계층은 Business Logic 계층을 알고 있고, Business Logic 계층은 Data Access 계층을 알고 있다.</p>

<p>장바구니에 상품을 추가하는 상황이라면, <br />
사용자가 장바구니 담기 버튼을 누름: UI 계층에서 상호작용 인식 <br />
사용자의 장바구니 리스트에 상품을 추가함: 비즈니스 로직 계층에서 수행 <br />
사용자의 장바구니 리스트를 DB에 업데이트함: 데이터 접근 계층에서 업데이트 쿼리 실행 <br />
DB 업데이트 결과에 따른 후속 작업(실패 시 장바구니 리스트에서 상품 삭제): 비즈니스 로직 계층에서 수행 <br />
장바구니 상태 보여줌: UI 계층에서 수행 <br />
이렇게 수행된다.</p>

<p>계층 아키텍처는 <strong>데이터베이스 주도 설계</strong>를 유도한다. <br />
계층 아키텍처를 사용하면 개발을 할 때 데이터베이스 위주로 사고를 하게 된다는 뜻이다. <br />
예를 들면 다음과 같은 순서로 개발을 하는 것이다. <br />
먼저 해당 기능에 필요한 데이터를 기준으로 데이터베이스 테이블을 구성한다. <br />
그리고 해당 테이블에 데이터를 삽입하거나 가져오는 쿼리를 작성한다. <br />
쿼리를 통해 가져온 데이터를 토대로 어떤 기능을 수행하도록 하는 코드를 작성한다. <br />
이러한 방식이 나쁜 것은 아니지만 기능의 <strong>목적</strong>에 집중하는 것이 아닌 <strong>데이터</strong>에 집중하게 되어 코드를 보았을 때 기능의 목적을 파악하기 어렵다. <br />
또한 개발자가 편한 사고 방식이므로 개발자가 아닌 사람과 소통을 할 때 오류가 발생할 수 있다. <br />
계층 아키텍처가 데이터베이스 주도 설계를 유도한다고 해서 도메인 주도 설계를 적용할 수 없다는 뜻은 아니니 이 점을 유의해야 한다.</p>

<h4 id="clean-architecture">Clean Architecture</h4>
<p>2012년에 Robert C. Martin(a.k.a. Uncle Bob)에 의해 소개되었다. <br />
Onion Architecture(양파 아키텍처)와 도메인 주도 설계의 핵심을 합한 아키텍처이다. <br />
어니언 아키텍처는 비즈니스 로직과 인터페이스 어댑터(외부 시스템과 통신하기 위해 사용하는 것)를 분리하는 것이 핵심인 아키텍처이다. <br />
Domain Layer, Application Layer, User Interface Layer, Infrastructure Layer로 분리되어 있다.</p>
<ul>
  <li>Domain Layer - 엔터프라이즈 비즈니스 규칙을 정의하는 <strong>Entity</strong>가 존재한다.</li>
  <li>Application Layer - 비즈니스 역할을 수행하는 <strong>Use Case</strong>가 있다.</li>
  <li>User Interface Layer - 데이터를 가져오는 <strong>Repository</strong>와 User Interface를 다루는 <strong>Controller</strong>, <strong>Presenter</strong>가 함께 존재하는 계층이다.</li>
  <li>Infrastructure Layer - 어떤 <strong>DB</strong>, 어떤 <strong>프레임워크</strong>를 사용하는지와 같은 매우 구체적으로 구현된 부분이다.</li>
</ul>

<p>도메인 계층과 어플리케이션 계층이 구분되기 때문에 패키지와 파일 구조를 살펴보는 것만으로도 어떠한 기능이 수행되는지 파악하기 쉽다.</p>

<p>의존성은 도메인 계층으로 향한다. <br />
도메인 계층은 사용 당하기만 한다. <br />
어플리케이션 계층은 도메인 계층에 의존해야 하며 어떠한 계층도 데이터(여기에선 Repository)에 의존하지 않는다. <br />
어플리케이션 계층이 데이터를 모르는데 어떻게 비즈니스 로직을 수행할까? <br />
이를 위해 Dependency Inversion Principle(의존성 역전 원칙)을 이용한다. <br />
어플리케이션 계층은 레포지토리의 인터페이스를 참조하고, 실제 레포지토리의 구현체는 User Interface 계층에 작성하여 사용하는 것이다. <br />
만약 어플리케이션 계층이 데이터에 의존하였다면 A 레포지토리 대신 B 레포지토리를 써야 하는 경우에 어플리케이션 계층에서 A 레포지토리를 사용했던 부분을 B 레포지토리로 바꿔줘야 겠지만 인터페이스를 참조하여 개발했다면 B 레포지토리가 해당 인터페이스의 구현체인 경우 어플리케이션 계층의 코드 변경없이 그대로 사용할 수 있다. <br />
확장성이 높아진 것이다. <br />
다만 이렇게 인터페이스를 작성하게 되면 계층 아키텍처에 비해 파일 개수가 많아지게 된다.</p>

<h4 id="differences">Differences</h4>
<p>계층 아키텍처는 Data Centric(데이터 중심) 아키텍처이기 때문에 비즈니스 의도를 반영하지 않는다. <br />
데이터 중심으로 이름을 붙이고 Use Case뿐만 아니라 모든 것들이 데이터 중심으로 정해진다. <br />
클린 아키텍처는 도메인이 중심이다. <br />
프로그램을 만드는 이유가 특정 문제를 소프트웨어로 해결하기 위함이니 해결할 문제를 중점으로 두고 프로그램을 설계한다는 것이다.</p>

<p>계층 아키텍처는 Business Logic 계층이 비즈니스 규칙과 역할을 모두 담당한다. <br />
그러나 클린 아키텍처에서는 이를 Domain과 Application 계층으로 분리한다. <br />
SOLID 원칙의 관점에서 보면 계층 아키텍처의 Business Logic 계층은 여러 책임을 가지게 되므로 단일 책임 원칙에 위배된다. <br />
SOLID 원칙을 지키고자 한다면 클린 아키텍처와 같이 비즈니스 규칙과 역할을 분리하는 것이 옳을 것이다.</p>

<h4 id="conclusion">Conclusion</h4>
<p>아키텍처를 사용하는 목적은 전체 개발 프로세스를 간단하게 만들기 위함이다. <br />
특히 아키텍처를 사용하면 유지보수 비용을 줄이는데 용이하다. <br />
더 자세히 말하면 특정 인프라에 대한 의존성을 줄여서(관심사를 분리해서) 변경이 용이하고 확장성이 높은 코드를 만들어 코드를 이해하고 수정하는 시간을 절감하는 것이다.</p>

<p>계층 아키텍처는 구조가 단순해서 추가적인 지식없이 쉽게 구조를 파악할 수 있다는 장점이 있지만 실제로 어떤 기능이 포함되어 있는지 파악하기 어렵다는 단점이 있다. <br />
클린 아키텍처는 프로젝트가 어떤 일을 하는지 파악하기 쉽다는 장점이 있지만 패키지 구조가 복잡하고 계층 분리를 위해 인터페이스를 작성해야 하기 때문에 단순한 기능을 구현할 때도 많은 양의 코드를 작성해야 한다는 단점이 있다. <br />
각 아키텍처의 장단점을 비교해보았을 때 규모가 작은 프로젝트의 경우에는 빠른 개발을 위해 구조가 단순하고 익숙한 계층 아키텍처를 선택하는 것이 괜찮아 보인다. <br />
규모가 크고 여러 인원이 진행하는 프로젝트는 클린 아키텍처를 적용하는 것이 추후 유지보수를 진행할 때 도움이 될 것이다.</p>

<p>클린 아키텍처 설명을 처음 봤을 때는 일단 용어가 무슨 뜻인지 모르거나 헷갈려서 이해하는데 어려움이 있었다. <br />
어떤 사람은 Application 계층이라 하고 어떤 사람은 Use Case 계층이라 해서 뭐가 맞는 건지 혼란스러웠는데 그냥 혼용해서 사용하는 구나 하고 받아들이니 그때부턴 괜찮았다. <br />
그러다 다시 ‘어니언 아키텍처’같은 모르는 개념이 나오면 그것에 대해 공부하고 또 그 설명에서 모르는 개념이 나와서 공부하고 이걸 계속 반복했다. <br />
마치 사칙연산도 모르면서 분수의 나눗셈을 이해하려한 것 같았다. <br />
계속해서 학습하고 용어들도 눈에 익고 익숙해지니 다시 클린 아키텍처 설명을 봤을 때 내용이 이해가 가기 시작했다. <br />
그때부턴 실제 개발을 할 때는 어떻게 쓰이는 것인가를 계속해서 생각하고 찾아보며 정말 개념을 완전히 이해하기 위해 관련 영상과 글을 반복해서 읽었다. <br />
그 결과 이렇게 포스트를 작성할 수 있게 되었다. <br />
글에 다소 부족한 점이 있을 수는 있지만 나중에 이 글을 다시 읽었을 땐 그 점을 보완할 수 있으리란 생각이 든다. <br />
안드로이드 앱의 경우 구글에서 앱 개발 시 권장하는 아키텍처를 설명한 글이 있기 때문에 다음 포스트에는 해당 문서를 읽고 정리할 계획이다. <br />
다음 포스트까지 작성 후에 현재 진행하고 있는 OlymPos에 어떤 아키텍처를 사용할 것인지 선정하여 적용할 것이다.</p>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://youtu.be/0JRI-xq10yo?si=W3Om3caHBoqpudlb">The Great N-layer vs Clean Architecture Debate</a></li>
  <li><a href="https://youtu.be/s5I149CBC7Y?si=NI5eVIBUSGGESRpd">Introduction to Clean Architecture &amp; Problems with Layered Architecture</a></li>
  <li><a href="https://meetup.nhncloud.com/posts/345">요즘 핫한 Clean Architecture 왜 쓰는 거야?</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin Coroutines 정리: 2</title>
	  <link>/2023-09-23-Kotlin-Coroutines-2</link>
	  <author></author>
	  <pubDate>2023-09-23T23:29:52+09:00</pubDate>
	  <guid>/2023-09-23-Kotlin-Coroutines-2</guid>
	  <description><![CDATA[
	     <h4 id="launch--async">Launch &amp; Async</h4>
<ul>
  <li>launch - 새로운 Coroutine을 시작하며 호출자에게 결과를 반환하지 않는다.</li>
  <li>async - 새로운 Coroutine을 시작하며 <em>await</em>라는 suspend 함수로 결과를 반환할 수 있다.</li>
</ul>

<p>async는 Coroutine 내부에서만 사용하거나 suspend 함수 내에서 작업을 병렬적으로 처리할 때 사용한다. <br />
suspend 함수 내에서 시작되는 Coroutine은 함수가 반환되면 중지되어야 한다. <br />
그러므로 반환 전에 Coroutine이 완료되도록 보장해야 한다. <br />
이를 위해 여러 Coroutine을 실행할 수 있는 <strong>coroutineScope</strong>를 정의할 수 있다. <br />
그리고 <strong>await()</strong> , <strong>awaitAll()</strong> 을 사용하여 함수가 반환되기 전에 Coroutine이 완료되도록 보장할 수 있다. <br />
아래 코드는 async를 통해 시작한 Coroutine을 await 함수를 사용하여, 실행된 Coroutine이 결과를 반환할 때 까지 기다린다. <br />
그러나 await 함수를 사용하지 않았더라도 coroutineScope Builder는 모든 Coroutine이 완료될 때 까지 기다린다. <br />
또한 coroutineScope는 Coroutine이 발생시키는 Exception(예외)를 호출자에게 전파한다. <br />
await()를 사용한 코드는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>suspend fun fetchTwoDocs() =
    coroutineScope {
        val deferredOne = async { fetchDoc(1) }
        val deferredTwo = async { fetchDoc(2) }
        deferredOne.await()
        deferredTwo.await()
    }
</code></pre></div></div>

<p>awaitAll()을 사용한 코드는 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// called on any Dispatcher (any thread, possibly Main)
suspend fun fetchTwoDocs() =
    coroutineScope {
        // fetch two docs at the same time
        val deferreds = listOf(
            // async returns a result for the first doc
            async { fetchDoc(1) },
            // async returns a result for the second doc
            async { fetchDoc(2) }
        )

        // use awaitAll to wait for both network requests
        deferreds.awaitAll()
    }
</code></pre></div></div>

<h4 id="coroutinescope">CoroutineScope</h4>
<p>CoroutineScope는 launch 혹은 async로 생성된 Coroutine을 추적한다. <br />
실행 중인 Coroutine은 <em>scope.cancel()</em> 을 호출하여 취소할 수 있다. <br />
ViewModel이나 Lifecycle은 자체 CoroutineScope를 제공한다. <br />
ViewModel은 viewModelScope가 있고, Lifecycle에는 lifecycleScope가 있다. <br />
그러나 CoroutineScope는 Coroutine을 실행하진 않는다. <br />
<em>scope.cancel()</em> 에 의해 Coroutine이 한 번 취소되면 다시는 해당 scope에서 Coroutine을 생성할 수 없다. <br />
즉, <em>scope.cancel()</em> 은 해당 클래스가 destroy된 경우에만 사용해야 한다. <br />
ViewModel의 경우 <em>onCleared()</em> 메서드에서 자동으로 취소된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExampleClass {

    // Job and Dispatcher are combined into a CoroutineContext which
    // will be discussed shortly
    val scope = CoroutineScope(Job() + Dispatchers.Main)

    fun exampleMethod() {
        // Starts a new coroutine within the scope
        scope.launch {
            // New coroutine that can call suspend functions
            fetchDocs()
        }
    }

    fun cleanUp() {
        // Cancel the scope to cancel ongoing coroutines work
        scope.cancel()
    }
}
</code></pre></div></div>

<h4 id="job">Job</h4>
<p><strong>Job</strong>은 Coroutine을 다루기 위해 사용한다. <br />
launch나 async로 만들어진 Coroutine은 Coroutine을 고유하게 식별하고 lifecycle을 관리하는 Job 인스턴스를 반환한다. <br />
다음 예시 코드와 같이 Job을 CoroutineScope에 전달하여 lifecycler을 관리할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExampleClass {
    ...
    fun exampleMethod() {
        // Handle to the coroutine, you can control its lifecycle
        val job = scope.launch {
            // New coroutine
        }

        if (...) {
            // Cancel the coroutine started above, 
            // this doesn't affect the scope
            // this coroutine was launched in
            job.cancel()
        }
    }
}
</code></pre></div></div>

<h4 id="coroutinecontext">CoroutineContext</h4>
<p>CoroutineContext는 다음 요소를 사용하여 Coroutine의 동작을 정의한다.</p>
<ul>
  <li>Job: Coroutine의 lifecycle 제어</li>
  <li>CoroutineDispatcher: 적절한 Thread에 작업 전달</li>
  <li>CoroutineName: Coroutine의 이름. 디버깅 시 사용</li>
  <li>CoroutineExceptionHandler: uncaught Exception 처리</li>
</ul>

<p>scope 내에서 만들어진 Coroutine은 새로운 Job 인스턴스가 새 Coroutine에 할당되고 CoroutineContext 요소는 해당 scope에서 상속된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExampleClass {
    val scope = CoroutineScope(Job() + Dispatchers.Main)

    fun exampleMethod() {
        // Starts a new coroutine on Dispatchers.Main 
        // as it's the scope's default
        val job1 = scope.launch {
            // New coroutine with CoroutineName = "coroutine" (default)
        }

        // Starts a new coroutine on Dispatchers.Default
        val job2 = scope.launch(
            Dispatchers.Default + CoroutineName("BackgroundCoroutine")
            ) {
                // New coroutine with CoroutineName 
                // = "BackgroundCoroutine" (overridden)
        }
    }
}
</code></pre></div></div>

<h4 id="recommendation">Recommendation</h4>
<h5 id="inject-dispatcher">Inject Dispatcher</h5>
<p>새 Coroutine을 만들거나 withContext를 호출할 때 Dispatchers를 하드코딩 하지 않는 것이 좋다. <br />
하드코딩 시 테스트가 어렵기 때문이다.</p>
<h5 id="안전한-suspend-함수">안전한 suspend 함수</h5>
<p>suspend 함수는 메인 Thread에서 호출하기 때문에 main-safe 해야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class NewsRepository(private val ioDispatcher: CoroutineDispatcher) {

    // As this operation is manually retrieving the news from the server
    // using a blocking HttpURLConnection, it needs to move the execution
    // to an IO dispatcher to make it main-safe
    suspend fun fetchLatestNews(): List&lt;Article&gt; {
        withContext(ioDispatcher) { }
    }
}

// This use case fetches the latest news and the associated author.
class GetLatestNewsWithAuthorsUseCase(
    private val newsRepository: NewsRepository,
    private val authorsRepository: AuthorsRepository
) {
    // This method doesn't need to worry about moving the execution of the
    // coroutine to a different thread as newsRepository is main-safe.
    // The work done in the coroutine is lightweight as it only creates
    // a list and add elements to it
    suspend operator fun invoke(): List&lt;ArticleWithAuthor&gt; {
        val news = newsRepository.fetchLatestNews()

        val response: List&lt;ArticleWithAuthor&gt; = mutableEmptyList()
        for (article in news) {
            val author = authorsRepository.getAuthor(article.author)
            response.add(ArticleWithAuthor(article, author))
        }
        return Result.Success(response)
    }
}
</code></pre></div></div>
<h5 id="viewmodel에서의-coroutine-생성">ViewModel에서의 Coroutine 생성</h5>
<p>View에서 Coroutine을 만들고 ViewModel에서 suspend 함수를 사용하지 말아야 한다. <br />
이러한 경우 테스트가 어렵고 configuration 변경에 수동으로 처리해야 한다. <br />
ViewModel에서 Coroutine을 생성한다면 단위 테스트를 진행할 수 있고, viewModelScope에서 실행된 작업은 configuration 변경에도 자동으로 유지된다.</p>
<h5 id="globalscope-금지">GlobalScope 금지</h5>
<p>GlobalScope는 어느 Job에도 종속되지 않고, Application의 lifecycle을 따른다. <br />
그러나 테스트가 어렵고 실행을 제어할 수 없으며 공통 CoroutineContext를 가질 수 없다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// DO inject an external scope instead of using GlobalScope.
// GlobalScope can be used indirectly. Here as a default parameter makes sense.
class ArticlesRepository(
    private val articlesDataSource: ArticlesDataSource,
    private val externalScope: CoroutineScope = GlobalScope,
    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default
) {
    // As we want to complete bookmarking the article even if the user moves
    // away from the screen, the work is done creating a new coroutine
    // from an external scope
    suspend fun bookmarkArticle(article: Article) {
        externalScope.launch(defaultDispatcher) {
            articlesDataSource.bookmarkArticle(article)
        }
            .join() // Wait for the coroutine to complete
    }
}

// DO NOT use GlobalScope directly
class ArticlesRepository(
    private val articlesDataSource: ArticlesDataSource,
) {
    // As we want to complete bookmarking the article
    // even if the user moves away from the screen,
    // the work is done creating a new coroutine with GlobalScope
    suspend fun bookmarkArticle(article: Article) {
        GlobalScope.launch {
            articlesDataSource.bookmarkArticle(article)
        }
            .join() // Wait for the coroutine to complete
    }
}
</code></pre></div></div>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://developer.android.com/kotlin/coroutines">Kotlin coroutines on Android</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin Coroutines 정리: 1</title>
	  <link>/2023-09-22-Kotlin-Coroutines-1</link>
	  <author></author>
	  <pubDate>2023-09-22T23:20:06+09:00</pubDate>
	  <guid>/2023-09-22-Kotlin-Coroutines-1</guid>
	  <description><![CDATA[
	     <p>Kotlin을 사용해 Android 앱 개발을 하는 사람이라면 비동기적으로 코드를 실행시키기 위해 Coroutine 한 번쯤은 다 써봤을 것이다. <br />
Coroutine을 사용해보았지만 기본 내용만 알고 Channel이나 Flow와 같은 심화 내용은 잘 모르는 사람도 많을 것이다.</p>

<p>OlymPos 프로젝트를 시작하게 되면서 MVVM 패턴이나 Jetpack Compose와 같이 알고 있었지만 제대로 사용해본 적은 없던 기술을 사용하게 됐다. <br />
그러면서 내부 코드들도 최신 기술로 채우고 싶다는 열망이 가득했다. <br />
그래서 먼저 그동안 미뤄왔던 Coroutine 공부를 시작했다. <br />
Coroutine은 초반부 내용이 쉬워서 조금만 배워도 금방 적용할 수 있지만 Channel이나 Flow 같은 도구들의 활용 부분부터는 러닝커브가 가파른 것으로 알려져 있다. <br />
목표는 Channel과 Flow까지 학습해서 프로젝트에 사용하는 것으로 잡았다.</p>

<h4 id="coroutine-이란">Coroutine 이란</h4>
<p>Coroutine은 비동기적으로 코드를 수행하는 동시성 디자인 패턴이다. <br />
<strong>Suspension</strong>을 지원하기 때문에 단일 Thread에서 다수의 Coroutine을 사용할 수 있다. <br />
Suspension은 실행 중인 Thread를 block(차단)하지 않는 것을 말하는데, 이로 인해 메모리가 절약된다. <br />
<strong>Structed concurrency</strong>를 사용하여 scope 내에서 작업들이 수행된다. <br />
Coroutine 계층 구조를 통해 <strong>Cancellation</strong>이 전달된다.</p>

<h4 id="setup">Setup</h4>
<p>Coroutine을 사용하려면 build.gradle(:app)에 아래의 dependency를 추가해야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    &lt;!-- 2023.09.22 기준 최신 버전은 1.6.4 --&gt;
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4'
}
</code></pre></div></div>

<h4 id="executing-in-a-background-thread">Executing in a background thread</h4>
<p>메인 Thread(UI Thread)에서 네트워크 요청을 보내면 응답을 받을 때까지 Thread가 wait(대기)하거나 block(차단)된다. <br />
이를 방지하기 위해 Coroutine을 사용해서 이 동작을 메인 Thread 외부에서 실행할 수 있다. <br />
<em>viewModelScope</em>는 ViewModel KTX extensions에 사전 정의된 CoroutineScope이다. <br />
<em>launch()</em> 는 Coroutine을 생성하고 Dispatcher에 함수 body 실행을 전달한다. <br />
<em>Dispatchers.IO</em>는 해당 Coroutine이 I/O 작업을 위한 Thread에서 실행되야 함을 나타낸다. <br />
이 Coroutine은 ViewModel scope에서 실행되므로, ViewModel이 소멸되면 실행 중인 모든 Coroutine이 취소된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        // Create a new coroutine to move the execution off the UI thread
        viewModelScope.launch(Dispatchers.IO) {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            loginRepository.makeLoginRequest(jsonBody)
        }
    }
}
</code></pre></div></div>

<h4 id="withcontext">withContext</h4>
<p>함수 사용 시 메인 Thread에서 UI 업데이트를 차단하지 않을 때 main-safe 하다고 간주한다. <br />
<em>makeLoginRequest()</em> 를 메인 Thread에서 호출하면 UI가 차단되므로 이 함수는 main-safe 하지 않다. <br />
위의 코드에서 <em>makeLoginRequest()</em> 는 viewModelScope에서 동작하는데, 이 scope는 메인 Thread에서 실행되고 있다.
이때 <strong>withContext()</strong> 함수를 사용하여 Coroutine을 다른 Thread에서 실행할 수 있다. <br />
<strong>withContext(Dispatchers.IO)</strong> 는 Coroutine 실행을 I/O Thread에서 수행할 수 있도록 한다. <br />
<strong>suspend</strong> 키워드는 이 함수가 Coroutine에서 호출되도록 강제한다. <br />
그리고 다른 suspend 함수에서 호출하거나 Coroutine Builder(ex. launch)를 사용하는 경우에만 호출할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class LoginRepository(...) {
    ...
    suspend fun makeLoginRequest(
        jsonBody: String
    ): Result&lt;LoginResponse&gt; {

        // Move the execution of the coroutine to the I/O dispatcher
        return withContext(Dispatchers.IO) {
            // Blocking network request code
        }
    }
}
</code></pre></div></div>

<h4 id="dispatchers">Dispatchers</h4>
<p>Dispatcher는 Coroutine 실행에 사용되는 Thread를 확인하기 위해 사용한다.</p>
<ul>
  <li><strong>Dispatchers.Main</strong> - 메인 Thread에서 Coroutine을 실행한다. UI와 상호작용을 하거나 빠른 작업을 수행할 때만 사용해야 한다. 예를 들어 UI 업데이트나 LivaData 객체를 업데이트 하는 경우에만 사용한다.</li>
  <li><strong>Dispatchers.IO</strong> - 메인 Thread 외부에서 Disk 또는 네트워크 I/O를 실행하도록 최적화되어 있다.</li>
  <li><strong>Dispatchers.Default</strong> - 메인 Thread 외부에서 CPU를 많이 사용하는 작업을 실행하도록 최적화되어 있다. 예를 들어 List를 정렬하거나 JSON을 파싱하는 경우에만 사용한다.</li>
</ul>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://developer.android.com/kotlin/coroutines">Kotlin coroutines on Android</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Jetpack Compose Navigation 정리</title>
	  <link>/2023-09-21-Jetpack-Compose-Navigation</link>
	  <author></author>
	  <pubDate>2023-09-21T23:46:57+09:00</pubDate>
	  <guid>/2023-09-21-Jetpack-Compose-Navigation</guid>
	  <description><![CDATA[
	     <p>이 포스트는 Jetpack Compose Navigation에 대한 간단한 내용을 기술한다. <br />
자세한 내용은 하단의 Reference 참조.</p>

<h4 id="setup">Setup</h4>
<p>Compose Navigation을 사용하려면 build.gradle(:app)에 아래의 dependency를 추가해야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
    &lt;!-- 2023.09.21 기준 최신 버전은 2.7.2 --&gt;
    implementation 'androidx.navigation:navigation-compose:2.7.2'
}
</code></pre></div></div>

<h4 id="navcontroller">NavController</h4>
<p>NavController는 Navigation 컴포넌트의 중심 API이다. <br />
Stateful이며 앱의 화면과 각 화면 상태를 구성하는 Composable의 Back Stack을 추적한다. <br />
NavController는 이를 참조해야 하는 모든 Composable이 접근 가능한 곳에 만들어야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val navController = rememberNavController()
</code></pre></div></div>

<h4 id="navhost">NavHost</h4>
<p>NavHost는 Navigation Graph와 NavController를 연결한다. <br />
NavController는 반드시 단일 NavHost와 연결되어야 한다. <br />
Composable 간의 이동(Navigation)을 수행하면 NavHost의 콘텐츠는 자동으로 Recompose 된다. <br />
Navigation Graph에 속한 Composable들은 각각의 route와 연결된다. <br />
route는 Composable의 경로를 정의하는 String이다.</p>

<p>NavHost를 만들려면 Graph의 startDestination도 필요하다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NavHost(navController = navController, startDestination = "profile") {
    composable("profile") { Profile(/*...*/) }
    composable("friendslist") { FriendsList(/*...*/) }
}
</code></pre></div></div>

<h4 id="navigate">Navigate</h4>
<p>navigate() 메서드를 사용하여 Composable 간의 이동을 할 수 있다. <br />
이 메서드는 새로운 destination을 Back Stack에 추가한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>navController.navigate("friendslist")
</code></pre></div></div>

<h4 id="arguments">Arguments</h4>
<p>Composable 간의 매개변수 전달을 할 수 있다. <br />
전달된 매개변수는 NavBackStackEntry에서 인수를 추출해서 사용한다. <br />
복잡한 데이터 객체를 전달하지 않고 고유 식별자 또는 ID와 같은 필요한 최소 정보를 전달하는 것이 좋다. <br />
그 이유는 Navigation Pass Data를 참고.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NavHost(startDestination = "profile/{userId}") {
    composable("profile/{userId}") { backStackEntry -&gt;
        Profile(
            navController, 
            backStackEntry.arguments?.getString("userId")
        )
    }
}
</code></pre></div></div>

<p>매개변수는 선택적으로 전달할 수도 있다. <br />
쿼리 문법을 사용해야 하고, defaultValue나 nullability = true로 설정되어 있어야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>composable(
    "profile?userId={userId}",
    arguments = 
        listOf(navArgument("userId") { defaultValue = "user1234" })
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("userId"))
}
</code></pre></div></div>

<h4 id="deep-links">Deep links</h4>
<p><a href="https://developer.android.com/jetpack/compose/navigation?#deeplinks">딥 링크에 대한 설명</a></p>

<h4 id="nested-navigation">Nested Navigation</h4>
<p>Nested Graph로 앱 UI 특정 흐름을 모듈화할 수 있다. <br />
NavGraphBuilder의 확장 메서드로 만들어서 사용할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun NavGraphBuilder.loginGraph(navController: NavController) {
    navigation(startDestination = "username", route = "login") {
        composable("username") { ... }
        composable("password") { ... }
        composable("registration") { ... }
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NavHost(navController, startDestination = "login") {
    loginGraph(navController)
}
</code></pre></div></div>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://developer.android.com/jetpack/compose/navigation">Jetpack Compose Navigation</a></li>
  <li><a href="https://developer.android.com/guide/navigation/navigation-pass-data?#supported_argument_types">Navigation Pass Data</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Android 14 Behavior changes: all apps 정리</title>
	  <link>/2023-04-20-Android14-Behavior-changes-all-apps-summarize</link>
	  <author></author>
	  <pubDate>2023-04-20T00:35:13+09:00</pubDate>
	  <guid>/2023-04-20-Android14-Behavior-changes-all-apps-summarize</guid>
	  <description><![CDATA[
	     <p>이 포스트에서는 targetSdkVersion과 상관없이 Android 14에서 작동하는 모든 앱들에 영향을 미치는 주요 동작 변화(behavior changes)를 다룬다. <br />
이 변화들은 안드로이드 플랫폼의 성능, 보안 그리고 사용자 경험성 향상시키기 위해 도입되었다. <br />
안드로이드 개발자라면, Android 14에서 앱을 테스트해야 하고, 이러한 변화를 지원하기 위해 필요한 수정을 해야 한다.</p>

<p>다음은 Android 14에서 모든 앱에 적용되는 주요 동작 변화들이다.</p>

<h4 id="핵심-기능">핵심 기능</h4>
<ul>
  <li>SCHEDULE_EXACT_ALARM 권한의 기본 값이 거부(Denied)로 변경: <br />
 정확한 알람(Exact Alarm)은 정확한 시간에 발생해야 하는 사용자 지정 알림(user-intentioned notification) 혹은 action을 의미한다. Android 14부터 Android 13 이상을 타겟팅한 앱 설치 시 SCHEDULE_EXACT_ALARM 권한은 기본적으로 거부된다.</li>
  <li>앱이 캐시되는 동안 컨텍스트(Context) 기반 브로드캐스트들은 큐에 적재(queued): <br />
 Android 14에서 해당 브로드캐스트들은 사용자에게 보여지지 않으며 낮은 메모리 우선순위를 가지게 된다. 이는 Android 12에서 도입된 비동기 바인더 전환(async binder transaction)과 유사하다. 매니페스트에 정의된 브로드캐스트들은 큐에 쌓이지 않고, 해당 앱들은 브로드캐스트 전달을 위해 캐시 상태에서 삭제된다. 앱이 포그라운드로 돌아가는 등, 캐시 상태를 벗어나게 되면 시스템은 큐에 쌓인 브로드캐스트들을 전달한다. 어떤 브로드캐스트가 여러 인스턴스들을 가진다면 하나의 브로드캐스트로 합친다.</li>
  <li>앱은 자기 자신의 백그라운드 프로세스들만을 죽일 수 있음: <br />
 Android 14부터는 앱이 killBackgroundProcesses()를 호출하여 자기 자신의 백그라운드 프로세스만을 죽일 수 있게 된다. 만약 다른 앱의 백그라운드 프로세스를 죽이려 한다면 아무런 영향없이 로그캣에 경고 메세지만을 출력하게 된다. 안드로이드는 캐시된 앱을 백그라운드에 유지하고 시스템에 메모리가 필요할 때 죽이도록 설계되어 있다. 만약 앱이 다른 앱을 불필요하게 종료시킨다면 나중에 앱을 완전히 재시작해야 한다. 이는 캐시된 앱을 재시작하는 것보다 더 많은 리소스를 필요로 하기 때문에 시스템 성능 저하와 배터리 소모량이 증가할 우려가 있다.</li>
</ul>

<h4 id="보안">보안</h4>
<ul>
  <li>설치 가능한 최소 API 레벨: <br />
 사용자의 보안과 개인 정보 보호를 위해 Android 14부터 targetSdkVersion이 23 미만인 앱을 설치할 수 없다. SDK 버전 23 미만의 앱을 새로 설치하려고 한다면 설치에 실패하고, 로그캣에 다음과 같은 메세지를 남긴다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> INSTALL_FAILED_DEPRECATED_SDK_VERSION: App package must target at least SDK version 23, but found 7
</code></pre></div>    </div>
    <p>앱을 새로 설치하는 경우에만 해당되기 때문에, 기기를 Android 14로 업그레이드해도 targetSdkVersion이 23 미만인 앱들은 남아 있는다.</p>
  </li>
  <li>미디어 소유 패키지명(Media owner package name) 변경: <br />
 미디어 스토어(media store)는 특정 미디어 파일을 저장한 앱을 나타내는 OWNER_PACKAGE_NAME 컬럼에 대한 쿼리를 지원한다. 다음 조건 중 하나를 만족한다면 이 값이 바뀌게 된다.
    <ul>
      <li>미디어 파일을 저장한 앱에 다른 앱에 항상 표시되는 패키지 이름이 있음</li>
      <li>QUERY_ALL_PACKAGES 권한을 요청하는 앱</li>
    </ul>
  </li>
</ul>

<h4 id="사용자-경험">사용자 경험</h4>
<ul>
  <li>닫을 수 없는 알림 방식 개선: <br />
 닫을 수 없는 포그라운드 알림을 표시하는 경우, Android 14부터는 이 알림을 닫을 수 있도록 변경했다. Notification.FLAG_ONGOING_EVENT에서 Notification.Builder#setOngoing(true) 혹은 NotificationCompat.Builder#setOngoing(true)를 설정한 경우가 해당된다. 다음 조건에서는 적용되지 않는다.
    <ul>
      <li>폰이 잠겨 있는 경우</li>
      <li>사용자가 ‘모든 알림 지우기’ 작업을 선택한 경우(실수로 눌렀을 수도 있으므로)</li>
    </ul>

    <p>그리고 다음 사례들에서도 적용되지 않는다.</p>

    <ul>
      <li>MediaStyle에 의해 생성된 알림</li>
      <li>보안과 개인 정보 보호를 위한 제한 정책이 적용된 경우</li>
      <li>기기 정책 컨트롤러(Device policy controller)와 기업용 패키지인 경우</li>
    </ul>
  </li>
  <li>사진과 비디오에 대한 부분 접근 권한 부여: <br />
 (만약 ‘photo picker’를 사용하는 앱인 경우 다음 내용을 적용하지 않아도 된다.) <br />
 Android   14에서는 Android 13에 적용된 미디어 권한을 요청할 때 부분 접근 권한을 부여할 수 있다. 새로운 Dialog는 다음과 같은 권한 선택지를 보여준다.
    <ul>
      <li>Select photos and videos: Android 14에 추가된 선택지. 사용자는 특정 사진과 비디오만을 앱에서 사용할 수 있도록 선택할 수 있다.</li>
      <li>Allow all: 모든 사진과 비디오를 접근하도록 허용한다.</li>
      <li>Don’t allow: 모든 권한을 거부한다.</li>
    </ul>

    <p>이 사항을 앱에서 원활히 처리하고 싶다면 READ_MEDIA_VISUAL_USER_SELECTED 권한 선언을 고려해야 한다.</p>
  </li>
</ul>

<h4 id="접근성">접근성</h4>
<ul>
  <li>최대 200%의 비선형 글꼴 크기 조정(non-linear font scaling) 지원: <br />
 Android 14부터 저시력 사용자를 위해 최대 200%의 글꼴 크기 조정 옵션을 제공한다. 이미 앱에서 scaled pixels(sp) 단위로 텍스트 크기를 정의한 경우에는 큰 영향을 미치지 않는다. 그러나 UI 테스트를 수행하여 앱이 200%의 글꼴 크기를 가져도 사용성에 문제가 없는지 확인해야 한다. <br />
 <img src="/assets/images/2023-04-20-Android14-Behavior-changes-all-apps-summarize_1.png" width="100%" height="100%" title="Non-linear scaling" alt="Image: Non-linear scaling" />
 비선형 크기 조정이란, 화면의 텍스트 요소가 너무 커지는 것을 방지하기 위해 시스템에서 비선형 배율 곡선을 적용하는 것을 말한다. 이 크기 조정 방식은 큰 텍스트와 작은 텍스트의 크기가 같은 비율로 조정되지 않음을 뜻한다. (위 이미지 참조)</li>
</ul>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://developer.android.com/about/versions/14/behavior-changes-all">Behavior changes: all apps Android 14</a></li>
  <li><a href="https://android-developers.googleblog.com/2023/02/first-developer-preview-android14.html">The first developer preview of Android 14</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>Android Dev Summit 2022 : 'Migrate Your Apps to Android 13' 세션 후기</title>
	  <link>/2023-02-19-Android-Dev-Summit-Android13-review</link>
	  <author></author>
	  <pubDate>2023-02-19T16:00:37+09:00</pubDate>
	  <guid>/2023-02-19-Android-Dev-Summit-Android13-review</guid>
	  <description><![CDATA[
	     <h5 id="세션-내용-요약">세션 내용 요약</h5>

<ol>
  <li>Android 13 버전의 변화 <br />
 Android 13 버전이 릴리즈됨에 따라 모든 앱에 영향을 미치는 사항과 SDK 버전이 33 이상인 경우에만 영향이 미치는 사항이 생겼다. <br />
 모든 앱에 영향을 미치는 사항은 사용자에게 앱의 백그라운드 동작을 알리고 이를 제어할 수 있도록 하기 위함이다.
    <ol>
      <li>모든 앱에 영향을 미치는 사항
        <ul>
          <li>사용자가 포그라운드 서비스(이하 FGS)를 종료할 수 있도록 Task Manager 제공한다. <br />
 FGS가 실행 중이라면 이를 새로운 인터페이스에서 실행 중인 앱을 보고 종료할 수 있도록 한다. <br />
 adb 커맨드를 사용하여 FGS를 종료할 때와 동일한 상황을 테스트할 수 있다.
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> adb shell cmd activity stop-app PACKAGE_NAME
</code></pre></div>            </div>
            <p>force-stop 커맨드와도 유사한데, FGS Task Manager와는 다른 점이 있다.</p>
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> adb shell cmd activity force-stop PACKAGE_NAME
</code></pre></div>            </div>
            <p>FGS Task Manager로 인한 앱 종료 시에는 기록(History)에서 앱이 삭제되지 않고, 예약된 Job이 취소되지 않는다. <br />
 <img src="/assets/images/2023-02-19-Android13_1.jpg" width="100%" height="100%" title="Effects of closure" alt="Image: Effects of closure" />
 그렇기에 앱에 장기적인 영향이 덜 미친다. <br />
 FGS Task Manager에 의해 종료된 앱은 콜백을 받지는 않으나, 앱 시작 시 ApplicationExitInfo를 통해 당시 상황을 알 수 있다. <br />
 이를 통해 사용자에 의한 종료인지 여부와 오류, ANR, Exception, 메모리 부족 문제 등을 확인할 수 있다. <br />
 FGS Task Manager를 통해 데이터 손실이 최소화되도록 종료 명령을 처리하고, FGS가 정말 앱에 필요한지 확인해야 한다고 당부했다.</p>
          </li>
          <li>백그라운드 액티비티가 제한된 앱 대기 버킷(Restricted App Standby Bucket)으로 이동하기 까지 대기하는 기간이 45일에서 8일로 짧아졌다. <br />
 제한된 앱 대기 버킷은 Android 12에서 도입되었는데, Job들이 하루에 10분 동안만 수행이 되고, 긴급 Job들도 더 적게 실행이 되며, 알람도 하나만 호출할 수 있도록 하는 기능이다. <br />
 아래 코드를 통해, 앱이 해당 상태로 변경된 경우 필수적인 Job을 예약할 수 있도록 지원할 수 있다.
            <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">val</span> <span class="py">usageStatsManager</span> <span class="p">=</span> <span class="n">getSystemService</span><span class="p">&lt;</span><span class="nc">UsageStatsManager</span><span class="p">&gt;()</span>
 <span class="n">usageStatsManager</span><span class="o">?.</span><span class="nf">let</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">appStandbyBucket</span> <span class="p">==</span> <span class="nc">STANDBY_BUCKET_RESTRICTED</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>            </div>
            <p>Job과 알람을 실행할 때 앱 상태를 로깅(Logging)해야 예상치 못한 동작들을 추적할 수 있다. <br />
 앱 대기 버킷 상태도 adb로 테스트할 수 있다.</p>
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> adb shell am set-standby-bucket PACKAGE_NAME 45
</code></pre></div>            </div>
            <p>앱이 실행 중인 상태에서는 테스트 할 수 없다. <br />
 앱이 상호작용 중이기 때문에 버킷에서 빠져 나가기 때문이다. <br />
 앱이 제한된 버킷 상태로 가지 않으려면 해당 앱에 대한 상호작용과 함께 실행 가능한 알람을 받도록 사용자의 동의를 얻어야 한다. <br />
 Android 13 부터는 권한을 얻어야 해당 작업을 수행할 수 있다. <br />
 만약 사용자가 이 권한을 거부한다면 다시는 이 권한을 요청하지 않는다. <br />
 앱 삭제 후 재설치하거나, 앱이 SDK 버전 33에 타겟팅된 경우는 예외이다. <br />
 AndroidX 함수를 통해 앱에서 알림이 활성화 되었는지 확인할 수 있다.</p>
            <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">val</span> <span class="py">notificationsManagerCompat</span> <span class="p">=</span> 
  <span class="nc">NotificationManagerCompat</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
 <span class="n">notificationsManagerCompat</span><span class="p">.</span><span class="nf">areNotificationsEnabled</span><span class="p">()</span>
</code></pre></div>            </div>
            <p>adb 커맨드를 통해 권한을 삭제하여 테스트할 수 있다.</p>
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> adb shell pm revoke PACKAGE_NAME
 android.permission.POST_NOTIFICATIONS
 adb shell pm clear-permission-flags PACKAGE_NAME \
android.permission.POST_NOTIFICATIONS user-set
 adb shell pm clear-permission-flags PACKAGE_NAME \
android.permission.POST_NOTIFICATIONS user-fixed
</code></pre></div>            </div>
          </li>
          <li>앱이 SDK 버전 33에 타겟팅된 경우, 인텐트를 명시적으로 지정하여 인텐트 필터 요소와 일치하는 경우에만 전달되도록 동작이 변경되었다. <br />
 다른 앱에서 내부 코드를 갑자기 트리거하는 오류를 막기 위해 BroadcastReceiver에 허용되지 않은 intent.action을 방지하는 코드를 추가해야 한다.
            <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">intent</span><span class="p">.</span><span class="n">action</span><span class="p">.</span><span class="nf">equals</span><span class="p">(</span><span class="n">allowedAction</span><span class="p">))</span> <span class="p">{</span>
<span class="o">..</span><span class="p">.</span>
 <span class="p">}</span>
</code></pre></div>            </div>
          </li>
          <li>클립보드 콘텐츠를 시각적으로 확인하는 기능이 추가되었다. <br />
 이에 따라 개인 정보나 신용카드 정보 등 민감한 정보들을 복사했을 때 클립보드에 보여지지 않도록 처리해야 한다.
            <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// SDK version 33 or higher</span>
 <span class="n">clipData</span><span class="p">.</span><span class="nf">apply</span> <span class="p">{</span>
<span class="n">description</span><span class="p">.</span><span class="n">extras</span> <span class="p">=</span> <span class="nc">PersistableBundle</span><span class="p">().</span><span class="nf">apply</span> <span class="p">{</span>
  <span class="nf">putBoolean</span><span class="p">(</span><span class="nc">ClipDescription</span><span class="p">.</span><span class="nc">EXTRA_IS_SENSITIVE</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="p">}</span>
 <span class="p">}</span>
 <span class="c1">// SDK version lower than 33</span>
 <span class="n">clipData</span><span class="p">.</span><span class="nf">apply</span> <span class="p">{</span>
<span class="n">description</span><span class="p">.</span><span class="n">extras</span> <span class="p">=</span> <span class="nc">PersistableBundle</span><span class="p">().</span><span class="nf">apply</span> <span class="p">{</span>
  <span class="nf">putBoolean</span><span class="p">(</span><span class="s">"android.content.extra_IS_SENSITIVE"</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>SDK 버전 33에서 변화한 동작(Privacy를 중심으로)
        <ul>
          <li>
            <p>WiFi 주변 기기(Nearby WiFi Devices) 권한을 도입했다. <br />
 이전 안드로이드 버전에서는 주변 기기 탐색을 위해 WiFi Manager 클래스를 사용해야 했고, 위치 권한도 필요했다. <br />
 안드로이드 13에서는 NEARBY_WIFI_DEVICES 런타임 권한을 사용하여 Wifi Manager의 메소드나 위치 권한 없이 주변 기기를 쉽게 탐색할 수 있다.</p>

            <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span>
<span class="na">android:name=</span><span class="s">"android.permission.NEARBY_WIFI_DEVICES"</span>
<span class="na">android:usesPermissionFlags=</span><span class="s">"neverForLocation"</span> <span class="nt">/&gt;</span>
</code></pre></div>            </div>
            <p>앱을 SDK 버전 33에 타겟팅하는 경우, 주변 WiFi 기기 탐색 시 NEARBY_WIFI_DEVICES 권한을 요청하지 않는다면 많은 Exception을 일으키게 되니 이 점을 유의해야 한다.</p>
          </li>
          <li>미디어 권한이 세분화되었다. <br />
 이에 따라 READ_EXTERNAL_STORAGE 권한 대신 미디어 종류에 따라 다음과 같은 권한을 요청해야 한다. <br />
 <img src="/assets/images/2023-02-19-Android13_2.jpg" width="100%" height="100%" title="Granular media permissions" alt="Image: Granular media permissions" /></li>
          <li>
            <p>생체 신호 센서(Body sensor)를 백그라운드에서 사용하기 위해 허용해야 하는 권한이 추가되었다.</p>

            <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;uses-permission</span>
<span class="na">android:name=</span><span class="s">"android.permission.BODY_SENSORS_BACKGROUND"</span> <span class="nt">/&gt;</span>
</code></pre></div>            </div>
          </li>
          <li>더 이상 SDK에 포함되지 않는 인터페이스들이 있다. <br />
 해당 인터페이스는 다음 4개이며, 대체 인터페이스를 사용하면 된다. <br />
 <img src="/assets/images/2023-02-19-Android13_3.jpeg" width="100%" height="100%" title="Non-SDK interfaces" alt="Image: Non-SDK interfaces" /></li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h4 id="후기">후기</h4>

<p>최근 여러 기종에 대한 Android 13 업그레이드가 적용되면서 회사에서 서비스 중이던 한 모바일 앱에 크고 작은 문제들이 발생했었다. <br />
그런데 이에 대한 대비가 안 되어 있어, 급하게 수정 작업을 진행하여 배포가 이루어졌다고 한다. <br />
문제가 해결된 이후에 해당 모바일 앱의 유지보수 업무가 우리 팀으로 이관되면서 안드로이드 버전에 따른 앱 마이그레이션 사항을 살펴보게 되었다. <br />
안드로이드 개발자임에도 안드로이드 버전에 따른 변경 사항을 잘 알지 못했던 것은 지금까지 TV 앱 개발을 진행해왔기 때문이다. <br />
특히나 일반 TV 앱이 아니고, 특정 셋탑에 종속되는 앱이었기 때문에 더욱 관심도가 떨어져 있었다. <br />
아무리 TV 앱을 개발한다지만 어떻게 안드로이드 관련 최신 내용을 공부하지 않았냐고 묻는다면 딱히 할 말이 없다. <br />
지금이라도 하고자 하니 따뜻하게 바라봐 주길 바란다. <br />
<br />
일단 정리한 내용은 당장 주요하게 봐야 하는 것들이다. <br />
생략된 내용은 추후에 정리하고자 한다. <br />
‘모든 앱에 영향을 미치는 사항’은 뜬금없이 발생하는 오류를 막기 위해 꼭 숙지해야 하는 내용이라 주의 깊게 들었다. <br />
일단은 인텐트 관련 내용 말고는 유지보수 시 신경 써야 하는 내용은 없긴 했다. <br />
그래도 FGS와 버킷 관련 내용은 자칫하면 앱에 영향을 크게 미칠 수 있는 것들이라, 최대한 꼼꼼히 살펴보았다. <br />
특히 버킷 관련 내용은 처음 듣는 내용이라 공식 문서를 읽었다. <br />
안정적인 앱 서비스를 위해 버킷 관련 예외 처리가 꼭 필요할 듯하다. <br />
권한 관련 추가 내용은 꼭 숙지해야 하는 사항이기에 세션에서 소개한 세부 세션을 들어볼 계획이다. <br />
<br />
Android 14의 개발자 프리뷰가 이미 공개되었고, 곧 베타 버전 공개도 예정되어 있으니 앞으로 이를 주의 깊게 살펴볼 계획이다. <br />
Android 13의 변경 사항은 늦게 알게 되었지만, Android 14는 미리 알아보고 준비해서 안정적인 서비스를 제공하도록 노력할 것이다.</p>

<hr />

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://youtu.be/wBx3-ZObxY8?list=PLWz5rJ2EKKc8PO99T1QQLrPAJILqxJXW6">Migrate Your Apps to Android 13</a></li>
</ol>

	  ]]></description>
	</item>

	<item>
	  <title>DEVIEW 2021 모바일: 'Android Jetpack Compose 실제 서비스 적용 후기' 세션 후기</title>
	  <link>/2023-02-05-DEVIEW-Mobile-Jetpack-Compose-review</link>
	  <author></author>
	  <pubDate>2023-02-05T21:30:11+09:00</pubDate>
	  <guid>/2023-02-05-DEVIEW-Mobile-Jetpack-Compose-review</guid>
	  <description><![CDATA[
	     <h5 id="세션-내용-요약">세션 내용 요약</h5>

<ol>
  <li>
    <p>적용 배경</p>

    <ul>
      <li>React-Native에서 Android Native로의 앱 리뉴얼 미션을 부여받음</li>
      <li>해당 앱이 적은 Spec과 화면을 가졌기에 Trouble Shooting에 부담이 없으리라 판단</li>
      <li>기존 Project가 View의 onDraw를 사용하는 자체 Framework이었기에 Jetpack Compose 개념 이해가 수월</li>
    </ul>
  </li>
  <li>
    <p>Jetpack Compose <br />
 기존의 Native UI는 명령을 통해 Page를 표시한다. <br />
 View를 XML로 미리 구성하고, findViewById나 binding으로 View를 불러와서 변화를 명령하는 방식이다. <br />
 선언형 Jetpack Compose는 모든 Page 구성요소가 정의 되어 있고, State에 따라서 표시 여부를 결정한다. <br />
 그리고 싶은 View를 모두 정의해놓고, State에 맞게 View를 선택적으로 그린다.</p>

    <p>Jetpack Compose를 사용하면 다음과 같은 장점이 있다.</p>
    <ol>
      <li>Build 속도가 줄어들어 생산성이 향상한다.</li>
      <li>APK 크기가 감소한다.<br />
   1, 2번에 대한 자세한 내용은 <a href="https://developer.android.com/jetpack/compose/ergonomics?hl=ko">Reference 3번</a>을 참조하면 된다.</li>
      <li>웹뷰와 같은 Native 기능과 Context를 쉽게 사용할 수 있다.</li>
      <li>Kotlin Code만으로 대부분의 UI 개발이 가능하다는 것도 큰 장점이다. XML과 Kotlin Code를 왕복하면서 개발할 필요 없기 때문에 개발자 입장에서는 더 편하다.</li>
      <li>RecyclerView와 Adapter 사용 없이 List를 만들 수 있다. RecyclerView를 사용하면 재사용되는 View 처리 등등 신경 써야 할 부분도 많고, 헷갈리는 부분도 많다. 그런데 이것 대신 Jetpack Compose 내에서 편리하게 Row, Column 기능을 사용할 수 있다.</li>
      <li>데이터(literals) 수정을 하면 Emulator에서 실시간(Live Edit)으로 볼 수 있다.</li>
      <li>State 변화로 인해 UI 갱신이 일어날 때 UI가 속한 Tree를 전부 탐색하는 것이 아닌, 변경되는 UI만 탐색하기 때문에 가볍다.</li>
    </ol>

    <p>당연히 단점도 존재하는 데 단점은 다음과 같다.</p>
    <ol>
      <li>LifeCycle 대응이 안 된다. Composable 내부에서 LifeCycle 변경 여부를 알아챌 수 없어서, Activity에서 LifeCycle 변경이 일어날 때 Composable에 이를 알려줘야 한다.</li>
      <li>같은 화면에 있는 Widget이 서로 다른 함수로 이루어져 있다면 변수를 공유할 수 없다. DI, 전역 관리, 매개변수 등을 사용해서 변수를 공유할 수 있도록 해야 한다.</li>
      <li>같은 Page에 속한 Widget들이 사용하는 State는 Widget의 상위인 Page에서 생성하여 관리한다. 그렇기 때문에 해당 Page가 삭제되면 Widget의 State도 초기화된다. 이처럼 State가 초기화되는 상황에서 값을 유지하기 위해서는 remember, rememberSaveable을 활용해야 한다. State 관리가 제대로 이루어지지 않으면 화면 갱신이 안 되거나, 원하는 데이터를 얻지 못할 수 있다.</li>
      <li>UI가 Activity Base 구성이 아니기 때문에, Firebase Tracking 활용 시 화면별 Tracking이 어렵다. 화면 진입 시점을 Logging에 추가해야 한다.</li>
      <li>아키텍처 자료가 부재하다. (2021.11. 발표이므로 이때 기준) MVC, MVVM, Clean Architecture 등 Jetpack Compose 사용과 관련한 아키텍처에 대한 자료를 찾아보기 힘들다.</li>
      <li>모든 Page가 State로 연결되어 관리되기 때문에 잘못된 구성으로 인한 오류 발생 여지가 존재한다. 논리적으로 구성만 잘 한다면 문제가 없겠지만, 세상에 완벽한 건 없는 법이다.</li>
    </ol>

    <p>Jetpack Compose 사용 시 주의해야 할 점은 다음과 같다.</p>
    <ol>
      <li>State가 변경되면 해당 State를 사용하는 전체 Composable 함수가 Recomposition되는게 아니라, 해당 함수 내에서 변경된 State를 사용하는 Composable만 Recomposition된다.</li>
      <li>State로 Model을 사용할 때 Model의 파라미터만 변경이 된 경우에는 Recomposition되지 않는다. Model 자체가 변경되어야 Recomposition된다.</li>
      <li>Composable은 여러 번 호출될 수 있기 때문에, 내부에서 한 번만 수행되어야 하는 함수들은 LaunchedEffect 등을 사용하여 호출이 다량 일어나지 않도록 해야 한다.</li>
      <li>Composable 내부에서는 변수 값이 변경되어도 Recomposition 되지 않기 때문에, 변수에 따라서 UI가 변경되어야 하는 경우에는 State를 사용해야 한다.</li>
      <li>Composable 내부에서 변수 사용 시 remember를 사용하지 않으면 Recomposition 과정에서 변수가 재생성된다. 객체 또한 마찬가지다.</li>
      <li>Parcelable, Serializable Object를 사용했을 때 Object 내부 값이 변경되지 않으면 Recomposition되지 않는다.</li>
    </ol>
  </li>
</ol>

<hr />

<h4 id="후기">후기</h4>

<p>Jetpack에 Compose라는 선언형 UI Framework가 있다는 사실은 처음 알았다. <br />
본 세션은 Compose에 대한 기본 개념을 이미 알고 있다는 것을 전제로 이루어졌기 때문에 Android Developer 문서를 간단하게 읽고 시청하였다. <br />
<br />
실제 서비스를 적용한 후기이다 보니 세세한 장단점을 알 수 있어서 좋았다. <br />
코드를 짜면서 겪는 사소한 일화들이 담긴 세션이었다. <br />
다만, Jetpack Compose를 처음 접한 사람에겐 다소 불친절한 세션이었다. <br />
아무래도 기본 개념을 설명하기엔 시간이 촉박해서 어쩔 수 없었을 것 같다. <br />
<br />
XML을 작성하지 않고 View를 구성할 수 있다는 점이 굉장히 매력적이었다. <br />
세션에서 장점으로 언급한 것과 같이, XML과 코드를 번갈아 가며 분석하는 것은 피곤한 일이다. <br />
Layout뿐만 아니라, Selector, Style 등도 같이 봐야 하니 번거롭다. <br />
그런데 이러한 파일없이 코드로만 작성하여 View를 편리하게 구현할 수 있으니 흥미로웠다. <br />
간단한 앱을 개발할 때는 Jetpack Compose 사용을 고려해봐도 괜찮을 것 같다.</p>

<h5 id="reference">Reference:</h5>

<ol>
  <li><a href="https://deview.kr/2021/sessions/478">Android Jetpack Compose 실제 서비스 적용 후기 / DEVIEW 2021</a></li>
  <li><a href="https://developer.android.com/jetpack/compose/documentation?hl=ko">https://developer.android.com/jetpack/compose/documentation?hl=ko</a></li>
  <li><a href="https://developer.android.com/jetpack/compose/ergonomics?hl=ko">https://developer.android.com/jetpack/compose/ergonomics?hl=ko</a></li>
</ol>

	  ]]></description>
	</item>


</channel>
</rss>
